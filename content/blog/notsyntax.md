---
title: Software development isn’t writing syntax
description: On AI assisted coding and software development
canonical: https://blog.glitch.com/post/software-development-isnt-writing-syntax
date: 2023-05-11
---
<!--
<img src="robots.png" alt="robots" />
-->

___This post was originally published at [blog.glitch.com](https://blog.glitch.com/post/software-development-isnt-writing-syntax).___

AI assisted coding has really taken off recently. The tech and [the conversation around it](https://blog.glitch.com/post/yes-code-coding-with-ai) say some interesting things about our understanding of what developers do.

AI can write some kinds of code, and it’s even helping people who aren’t coders to make software applications. It’s also frequently wrong. We’re still learning the types of coding task it’s suited to — in what specific contexts it’s a help rather than a hindrance. Unrealistic expectations and inaccurate interpretations abound! **The conversation reveals our inability to define the real skills in being a software developer.**

It’s not writing syntax. Being able to recite the right keywords only takes you so far.

## OK, what is it then?

Back when I was training for tech, an instructor told us a story about a research exercise. A mix of people looked at a code sample for a short time and tried to memorize as much of it as possible. Some had never written code, and some were experienced software engineers. The non-coders were able to recount detail about the first couple of lines from the top of the excerpt. The developers remembered almost none of that detail, but recounted a high level overview of the structures they had seen (a loop, a conditional, etc). The developers understood the code differently.

Code comprehension remains a neglected part of developer education, but this exercise reflects how integral it is to making software, and that abstraction level is a key aspect of working with code. The actual syntax is a *detail* — an important one, the code won’t work if it’s wrong — but focusing on syntax is only helpful at a granular level, it doesn’t come close to conveying what a developer actually does.

## Learning and context

When I see a job posting that requires experience in specific frameworks or programming languages, it always seems like such a missed opportunity. Software engineering is fundamentally a *learning* activity. Developers are always learning new technologies and solving new problems. Once you’ve learned one language you pick up more. What characterizes the more experienced developer is the ability to reapply skills in different contexts.

I’ve had the privilege to work with incredibly highly skilled software engineers, and if I were to try to describe their talents and contributions, writing correct or efficient syntax would not make the list lol. Part of it is going past “how” and delving into “why” — articulating the problem as it stands within an organizational or social context, making sure you’re solving the right problem, and defining it in an actionable way. There’s a ton of communication and collaboration, and being comfortable with ambiguity is hugely valuable. 

## Different interfaces

Shifting abstraction levels have given us an evolving definition of software engineering since the inception of coding. What seems like essential knowledge to one generation of coders becomes an invisible part of the stack to the next generation. There’s a strong argument that AI is another interface in this cycle. Remember the discussion a few years ago about knowing how to use effective phrasing for a Google search? The algorithms in the tools we use daily have advanced, but describing many of them as natural language processing is still a stretch. 

Everyone who interacts with tech figures out how to give the inputs that get the desired output, whether you’re writing code or adjusting your accent because the voice recognition tool can’t process Glaswegian — we learn how to get the machines to do what we want.

## Engaging with complexity

Increasing abstraction levels have been accompanied by the rise of the API — we make software by combining a lot of components towards a particular goal. Connecting all of these different tools means the activity is in part defined by its technological and community ecosystem. Software engineers make something valuable within a complex landscape of interacting systems. 

The modular style of making software is successful because it frees developers to focus their creativity on the parts of a project that make it *unique* — which are also the parts AI is least able to approach.

Making the web isn’t about writing code, it’s about being able to create and participate through technology. As it becomes harder to say what is and isn’t software development, maybe it becomes more interesting to ask other questions. For example, what does a tool enable people to do, what are the opportunities, and what are the risks of harm?
